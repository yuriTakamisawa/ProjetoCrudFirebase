ng value, if any.  Cheap and easy.
            is_path = IsPathSection(k)
            if is_path:
                to[k] = MakePathRelative(to_file, fro_file, v)
            else:
                to[k] = v
        elif type(v) is dict:
            # Recurse, guaranteeing copies will be made of objects that require it.
            if k not in to:
                to[k] = {}
            MergeDicts(to[k], v, to_file, fro_file)
        elif type(v) is list:
            # Lists in dicts can be merged with different policies, depending on
            # how the key in the "from" dict (k, the from-key) is written.
            #
            # If the from-key has          ...the to-list will have this action
            # this character appended:...     applied when receiving the from-list:
            #                           =  replace
            #                           +  prepend
            #                           ?  set, only if to-list does not yet exist
            #                      (none)  append
            #
            # This logic is list-specific, but since it relies on the associated
            # dict key, it's checked in this dict-oriented function.
            ext = k[-1]
            append = True
            if ext == "=":
                list_base = k[:-1]
                lists_incompatible = [list_base, list_base + "?"]
                to[list_base] = []
            elif ext == "+":
                list_base = k[:-1]
                lists_incompatible = [list_base + "=", list_base + "?"]
                append = False
            elif ext == "?":
                list_base = k[:-1]
                lists_incompatible = [list_base, list_base + "=", list_base + "+"]
            else:
                list_base = k
                lists_incompatible = [list_base + "=", list_base + "?"]

            # Some combinations of merge policies appearing together are meaningless.
            # It's stupid to replace and append simultaneously, for example.  Append
            # and prepend are the only policies that can coexist.
            for list_incompatible in lists_incompatible:
                if list_incompatible in fro:
                    raise GypError(
                        "Incompatible list policies " + k + " and " + list_incompatible
                    )

            if list_base in to:
                if ext == "?":
                    # If the key ends in "?", the list will only be merged if it doesn't
                    # already exist.
                    continue
                elif type(to[list_base]) is not list:
                    # This may not have been checked above if merging in a list with an
                    # extension character.
                    raise TypeError(
                        "Attempt to merge dict value of type "
                        + v.__class__.__name__
                        + " into incompatible type "
                        + to[list_base].__class__.__name__
                        + " for key "
                        + list_base
                        + "("
                        + k
                        + ")"
                    )
            else:
                to[list_base] = []

            # Call MergeLists, which will make copies of objects that require it.
            # MergeLists can recurse back into MergeDicts, although this will be
            # to make copies of dicts (with paths fixed), there will be no
            # subsequent dict "merging" once entering a list because lists are
            # always replaced, appended to, or prepended to.
            is_paths = IsPathSection(list_base)
            MergeLists(to[list_base], v, to_file, fro_file, is_paths, append)
        else:
            raise TypeError(
                "Attempt to merge dict value of unsupported type "
                + v.__class__.__name__
                + " for key "
                + k
            )


def MergeConfigWithInheritance(
    new_configuration_dict, build_file, target_dict, configuration, visited
):
    # Skip if previously visited.
    if configuration in visited:
        return

    # Look at this configuration.
    configuration_dict = target_dict["configurations"][configuration]

    # Merge in parents.
    for parent in configuration_dict.get("inherit_from", []):
        MergeConfigWithInheritance(
            new_configuration_dict,
            build_file,
            target_dict,
            parent,
            visited + [configuration],
        )

    # Merge it into the new config.
    MergeDicts(new_configuration_dict, configuration_dict, build_file, build_file)

    # Drop abstract.
    if "abstract" in new_configuration_dict:
        del new_configuration_dict["abstract"]


def SetUpConfigurations(target, target_dict):
    # key_suffixes is a list of key suffixes that might appear on key names.
    # These suffixes are handled in conditional eva